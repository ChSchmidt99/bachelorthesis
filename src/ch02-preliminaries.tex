\section{Preliminaries}
This section introduces all basic concepts needed to follow along with the rest of this thesis, while also putting some focus on notable historical work. Additional topics that are not part of the thesis, but still important to the overall context, are also touched on. To keep this work self-sustained, everything is explained from the ground up, no previous knowledge required.
\subsection{Path Tracing}
% TODO: Citation style, only cite year and write name
At the core of any ray tracing approach is the concept of a ray, usually in three-dimensional space. In this work the following representation is used.
\[P(t)=O+td\]
% TODO: Introduce math notation
Where the origin $O$ is some point within the scene space and the direction $d$ is some vector along which the ray travels in a straight line. Points along this line can be described using the distance $t$, with $P(0)=O$ and $P(1)=O+d$. 
% TODO: Add Ray tracing Figure
As illustrated in figure 1, this concept can be used to construct images. Rays are cast into a scene, originating at some common eye point and intersecting each pixel in the image plane to find its corresponding color. The first ray casting algorithm using such a technique was proposed by Appel\cite{appel1968}, only considering primary intersections and shadow rays towards a light source to determine whether a point is illuminated or not. Whitted\cite{whitted_improved_1980} expanded on that approach by introducing an algorithm that, upon finding an object intersection, generates secondary rays influencing the final pixel color. In addition to the previously mentioned shadows, these secondary rays allow rendering of reflections and refractions by recursively casting new rays in the reflection direction and blending all results. 
% TODO: Is it really more common?
A more common approach, especially in film and visual effects\cite{keller2015path_tracing_revolution}, is a closely related concept called path tracing\cite{kajiya_rendering_1986}. Instead of evaluating a single ray per pixel, multiple samples with slight offsets and random scattering are used to more accurately simulate light transport through a scene and approximate the rendering equation also introduced by Kajiya. Path tracing is a global illumination solution and thus produces more realistic results, while also allowing accurate rendering of distribution effects\cite{cook_distributed_1984} and inherently solving the problem of aliasing. 
\subsection{Path Tracing Optimizations}
The issue with path tracing is, that it requires many samples to produce plausible results as images without sufficient samples suffer from high-frequency noise. Tracing such a number of rays, while also maintaining interactive frame rates, simply is not possible at the moment and probably will not be in the foreseeable future, especially with Moore's law converging to an end. As a result, real-time path tracing would not be possible without optimizations reducing the rendering time by several orders of magnitudes. 
\subsubsection{Denoising}
A big leap towards reducing that number was achieved in recent years through the introduction of more advanced denoising techniques. Through denoising, the required samples-per-pixel can be reduced to a significantly lower number, going down to single sample with some techniques. Schied et al.~\cite{schied_spatiotemporal_2017} combines path tracing output with previous frame data and a noise free G-buffer generated using a rasterization pass, to feed a wavelet filter and produce a denoised, temporally stable sequence of images using only one path-per-pixel. Chaitanya et al.~\cite{chaitanya_interactive_2017} applies machine learning to the problem by using a convolutional neural network to map noisy input images to noise-free output. Other real-time reconstruction filters\cite{mara17towards,koskela2019bmfr} achieve similar results and opened up the door for real-time path tracing in the first place. However, denoising was not the focus of my work and will not be mentioned in the remainder of this thesis. Subsequently, the described path tracer produces noisy one sample-per-pixel output leaving the choice of denoising technique open, even though applying any denoising technique would be an interesting task for some future work.
% TODO: Metion DLSS?
% TODO: Add paragraph about importance sampling?
\subsubsection{Acceleration Data Structures}
Another essential optimization technique, and also the focus of this thesis, is improving path tracing itself by using acceleration data structures. As established, the essential operation in path tracing is finding intersections between a given ray and the traced scene. A naive approach would be to test the ray against all scene primitive, which in practice might be several million operations and thus too expensive. In practice, primitives are arranged in hierarchical data structures, so that only a reduced number of ray intersection calculations is necessary. Approaches for generating such data structures can be divided into two categories, space subdivision and object subdivision~\cite{macDonald1988space}.

The former works by splitting the scene space recursively into smaller subregions, building a rooted tree with references to the objects in its leaves. These trees might be binary, as first proposed by Fuchs et al.~cite{fuchs1980bsp}, or have a higher branching factor, often referred to as a KD-tree. While KD-trees generally have a lower depth, binary trees allow for simpler traversal, as only a two-way decision is needed at each step. 

Glassner\cite{glassner_space_1984} described one of the earliest approaches for generating octrees that, for each recursive step, splits the given subspace at the spatial median along all three axis, resulting in eight new subregions. Kaplan\cite{kaplan_use_1985} expanded on that idea by introducing a very similar implementation utilizing binary trees instead of octrees. Fujimoto et al.~\cite{fujimoto_arts_1986}, while also using octrees, achieved a significant speed improvement by using incremental integer arithmetic to optimize the traversal algorithm. Traversal is also what these approaches excel in. Space is divided into disjoint subregions which can be tested in the order a ray passes through them. If a hit is found, the traversal algorithm can be terminated without checking further tree nodes, which is not as trivial in object subdivision approaches. One of the limitation of such approaches is, that an object might be in multiple subregions at once, so multiple leaves might contain pointers to the same object. This is problematic, because an intersection with the given object that lies outside the associated subregion might be found and thus needs to be checked during the traversal step. A valid approach for clipping objects to solve this problem was described by Havran and Bittner~\cite{Havran02onimproving} together with other traversal improvements utilizing a new termination criteria. More modern KD-tree construction algorithms~\cite{roccia2012kdtree,choi2010sahKdTree,wu2011sahKdTree} make use of the Surface Area Heuristic (SAH)~\cite{MacDonald2005HeuristicsFR} further improving their performance.

While space subdivision approaches have previously been regarded as the best acceleration data structure~\cite{havrand2000comparison}, object subdivision has since caught up and overtaken~\cite{vinkler2015comparison}, making it the most popular approach for path tracing. In addition, bounding volume hierarchies are very beneficial in dynamic scenes~\cite{wald_ray_2007}, as they can be re-fit efficiently on scene changes. Because of these advantages, only object subdivision approaches will be considered in the following sections of this thesis. 

% TODO: Introduce words like: primitive, ray tracing, path tracing, ray, AABB, OOB, Bounding sphere
% TODO: Introduce tree and tree notation 
Object subdivision, mostly in the form of a bounding volume hierarchy (BVH), was first mentioned by Clark~\cite{clark1976bvh} and also referenced by Whitted\cite{whitted_improved_1980} in his essential ray tracing paper. Each node of a BVH is spanned by a bounding volume and, depending on the branching factor $k$ of the tree, either contains $k$ children pointer or an arbitrary number of primitives in case of a leave node. 





Axis-aligned bounding boxes are the most popular bounding volume, mainly because it has the best balance between intersection