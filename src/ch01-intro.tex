\section{Introduction}
Ray tracing as a rendering technique simulates how light travels through a scene and thus inherently produces very realistic images. Effects that need to be computed explicitly in the contrasting approach of rasterization such as shadows, reflections and refractions are achieved by default albeit introducing a substantial computational cost. It is this simplicity paired with the high quality output, that made the method a staple in offline rendering where relatively long rendering times can be tolerated.

In real-time applications the time available to render a single frame is very limited making ray tracing a rather poor fit and leaving rasterization as the dominant approach over the past decades. Only in recent years has real-time ray tracing been enabled and opend up to a consumer market, especially through the use of special-purpose hardware. A particularly noteworthy milestone in that regard is NVIDIA's Turing architecture\cite{nvidia2017turing}, which is built in a way that accelerates basic ray tracing operations while also facilitating other methods essential to the process, most importantly more advanced denoising techniques. 

While this technology is undoubtedly a leap in the right direction, performance can still lack at times and additional software optimizations are necessary to support increasingly complex scenes. Additionally, such optimizations could decrease the power consumtion of graphic cards by decreasing the number of computations necessary and could be utilized by conventional ray tracing frameworks as well. Consequently, the search for better algorithms to accelerate ray tracing is still an interesting topic and was the main motivation behind this thesis. 

% TODO: Add references to the corresponding sections
In particular, this thesis provides a self-contained overview over the basics of real-time ray tracing as well as a broader outline over some related topics to make it as accessible as possible. All findings are based on an interactive CPU path tracer written from scratch in the programming language Go, which is elaborated further including some implementation details. This might be particularly helpful as a starting point for further research and optimizations. Furthermore, a closer look at bounding volume hierarchies is presented, and the approach of progressive hierarchical refinement\cite{hendrich_parallel_2017} is introduced as a state-of-the-art algorithm to construct such acceleration structures. The integration of the aforementioned approach into an interactive path tracer is described and validated, as this was still an open topic. Finally, two methods for optimizing hyperparameters related to the construction algorithm in real-time are introduced, evaluated and discussed.